// lib/src/features/songbook/repository/song_repository.dart
// Enhanced Song Repository with Firebase path safety and collection migration
// Handles collection names with spaces and special characters

import 'dart:convert';
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:lpmi40/src/features/songbook/models/song_model.dart';
import 'package:lpmi40/src/core/services/firebase_service.dart';

// ============================================================================
// RESULT WRAPPER CLASSES
// ============================================================================

/// Original wrapper class for holding a full list of songs
class SongDataResult {
  final List<Song> songs;
  final bool isOnline;

  SongDataResult({required this.songs, required this.isOnline});
}

/// Wrapper class for paginated lazy-loading results
class PaginatedSongDataResult {
  final List<Song> songs;
  final bool isOnline;
  final String? lastKey;
  final bool hasMore;

  PaginatedSongDataResult({
    required this.songs,
    required this.isOnline,
    required this.hasMore,
    this.lastKey,
  });
}

/// Wrapper class for single song with status
class SongWithStatusResult {
  final Song? song;
  final bool isOnline;

  SongWithStatusResult({required this.song, required this.isOnline});
}

/// Extended result classes for collection-aware operations
class UnifiedSongDataResult {
  final List<Song> songs;
  final bool isOnline;
  final int legacySongs;
  final int collectionSongs;
  final List<String> activeCollections;

  UnifiedSongDataResult({
    required this.songs,
    required this.isOnline,
    required this.legacySongs,
    required this.collectionSongs,
    required this.activeCollections,
  });

  int get totalSongs => songs.length;
  bool get hasCollectionSongs => collectionSongs > 0;
  bool get hasLegacySongs => legacySongs > 0;
  bool get isHybridMode => hasCollectionSongs && hasLegacySongs;
}

class SongSearchResult {
  final List<Song> songs;
  final bool isOnline;
  final String searchTerm;
  final int totalMatches;
  final Map<String, int> collectionMatches; // collectionId -> match count

  SongSearchResult({
    required this.songs,
    required this.isOnline,
    required this.searchTerm,
    required this.totalMatches,
    required this.collectionMatches,
  });
}

class SongAvailabilityResult {
  final Song? song;
  final bool isOnline;
  final bool foundInLegacy;
  final bool foundInCollections;
  final List<String> availableInCollections;

  SongAvailabilityResult({
    required this.song,
    required this.isOnline,
    required this.foundInLegacy,
    required this.foundInCollections,
    required this.availableInCollections,
  });

  bool get isAvailable => song != null;
  bool get isInMultipleCollections => availableInCollections.length > 1;
}

/// Migration result class
class CollectionMigrationResult {
  final bool success;
  final String collectionId;
  final String originalPath;
  final String newPath;
  final int songsMigrated;
  final String? errorMessage;

  CollectionMigrationResult({
    required this.success,
    required this.collectionId,
    required this.originalPath,
    required this.newPath,
    required this.songsMigrated,
    this.errorMessage,
  });
}

// ============================================================================
// PARSING FUNCTIONS FOR COMPUTE ISOLATION
// ============================================================================

List<Song> _parseSongsFromFirebaseMap(String jsonString) {
  try {
    final Map<String, dynamic>? jsonMap = json.decode(jsonString);
    if (jsonMap == null) return [];
    final List<Song> songs = [];
    for (final entry in jsonMap.entries) {
      try {
        final songData = Map<String, dynamic>.from(entry.value as Map);
        final song = Song.fromJson(songData);
        songs.add(song);
      } catch (e) {
        debugPrint('‚ùå Error parsing song ${entry.key}: $e');
        continue;
      }
    }
    return songs;
  } catch (e) {
    debugPrint('‚ùå Error parsing Firebase map: $e');
    return [];
  }
}

List<Song> _parseSongsFromList(String jsonString) {
  try {
    final List<dynamic> jsonList = json.decode(jsonString);
    final List<Song> songs = [];
    for (int i = 0; i < jsonList.length; i++) {
      try {
        final songData = Map<String, dynamic>.from(jsonList[i] as Map);
        final song = Song.fromJson(songData);
        songs.add(song);
      } catch (e) {
        debugPrint('‚ùå Error parsing song at index $i: $e');
        continue;
      }
    }
    return songs;
  } catch (e) {
    debugPrint('‚ùå Error parsing list: $e');
    return [];
  }
}

Map<String, dynamic> _parseUnifiedSongsData(String jsonString) {
  try {
    final Map<String, dynamic> input = json.decode(jsonString);
    final Map<String, dynamic>? legacySongs = input['legacySongs'];
    final Map<String, dynamic>? collectionSongs = input['collectionSongs'];

    final List<Song> allSongs = [];
    final Set<String> processedSongNumbers = {};
    int legacyCount = 0;
    int collectionCount = 0;
    final List<String> activeCollections = [];

    // Process collection songs first (they take precedence)
    if (collectionSongs != null) {
      for (final collectionEntry in collectionSongs.entries) {
        final collectionId = collectionEntry.key;
        activeCollections.add(collectionId);

        if (collectionEntry.value is Map) {
          final songMap =
              Map<String, dynamic>.from(collectionEntry.value as Map);
          for (final songEntry in songMap.entries) {
            try {
              final songData =
                  Map<String, dynamic>.from(songEntry.value as Map);
              final song = Song.fromJson(songData);

              if (!processedSongNumbers.contains(song.number)) {
                allSongs.add(song);
                processedSongNumbers.add(song.number);
                collectionCount++;
              }
            } catch (e) {
              debugPrint(
                  '‚ùå Error parsing collection song ${songEntry.key}: $e');
            }
          }
        }
      }
    }

    // Process legacy songs (only if not already in collections)
    if (legacySongs != null) {
      for (final entry in legacySongs.entries) {
        try {
          final songData = Map<String, dynamic>.from(entry.value as Map);
          final song = Song.fromJson(songData);

          if (!processedSongNumbers.contains(song.number)) {
            allSongs.add(song);
            processedSongNumbers.add(song.number);
            legacyCount++;
          }
        } catch (e) {
          debugPrint('‚ùå Error parsing legacy song ${entry.key}: $e');
        }
      }
    }

    // Sort by song number
    allSongs.sort((a, b) =>
        (int.tryParse(a.number) ?? 0).compareTo(int.tryParse(b.number) ?? 0));

    return {
      'songs': allSongs,
      'legacyCount': legacyCount,
      'collectionCount': collectionCount,
      'activeCollections': activeCollections,
    };
  } catch (e) {
    debugPrint('‚ùå Error parsing unified songs data: $e');
    return {
      'songs': <Song>[],
      'legacyCount': 0,
      'collectionCount': 0,
      'activeCollections': <String>[],
    };
  }
}

List<Song> _parseSongsFromAssets(String jsonString) {
  try {
    final List<dynamic> jsonList = json.decode(jsonString);
    final List<Song> songs = [];
    for (int i = 0; i < jsonList.length; i++) {
      try {
        final songData = Map<String, dynamic>.from(jsonList[i] as Map);
        final song = Song.fromJson(songData);
        songs.add(song);
      } catch (e) {
        debugPrint('‚ùå Error parsing asset song at index $i: $e');
        continue;
      }
    }
    return songs;
  } catch (e) {
    debugPrint('‚ùå Error parsing assets: $e');
    return [];
  }
}

List<Song> _parseSongsFromCollectionMap(String jsonString) {
  try {
    final Map<String, dynamic>? jsonMap = json.decode(jsonString);
    if (jsonMap == null) return [];
    final List<Song> songs = [];
    for (final entry in jsonMap.entries) {
      try {
        final data = Map<String, dynamic>.from(entry.value as Map);
        songs.add(Song.fromJson(data));
      } catch (e) {
        debugPrint('‚ùå Error parsing collection song ${entry.key}: $e');
      }
    }
    return songs;
  } catch (e) {
    debugPrint('‚ùå Error parsing collection songs map: $e');
    return [];
  }
}

// ============================================================================
// MAIN SONG REPOSITORY CLASS
// ============================================================================

class SongRepository {
  // Firebase paths
  static const String _firebaseUrl =
      'https://lmpi-c5c5c-default-rtdb.firebaseio.com/';
  static const String _legacySongsPath = 'songs';
  static const String _collectionSongsPath = 'collection_songs';
  static const String _collectionsPath = 'song_collections';

  // Firebase service for proper connectivity checking
  final FirebaseService _firebaseService = FirebaseService();

  // Performance tracking
  final Map<String, DateTime> _operationTimestamps = {};
  final Map<String, int> _operationCounts = {};

  // Migration tracking
  final Map<String, String> _collectionIdMapping = {}; // original -> safe

  bool get _isFirebaseInitialized {
    try {
      Firebase.app();
      return true;
    } catch (e) {
      return false;
    }
  }

  FirebaseDatabase? get _database {
    if (!_isFirebaseInitialized) return null;
    try {
      return FirebaseDatabase.instance;
    } catch (e) {
      debugPrint('[SongRepository] Error getting database instance: $e');
      return null;
    }
  }

  // ============================================================================
  // FIREBASE PATH SAFETY METHODS
  // ============================================================================

  /// Sanitize collection ID for Firebase path usage
  String _sanitizeCollectionId(String collectionId) {
    final sanitized = collectionId
        .replaceAll(' ', '_') // Replace spaces with underscores
        .replaceAll('.', '_') // Replace dots
        .replaceAll('#', '_') // Replace hash
        .replaceAll('\$', '_') // Replace dollar sign
        .replaceAll('[', '_') // Replace square brackets
        .replaceAll(']', '_')
        .replaceAll('/', '_') // Replace forward slashes
        .replaceAll('\\', '_') // Replace backslashes
        .toLowerCase() // Convert to lowercase
        .replaceAll(
            RegExp(r'[^\w\-]'), '_'); // Replace any other non-word chars

    // Store mapping for reference
    if (collectionId != sanitized) {
      _collectionIdMapping[collectionId] = sanitized;
      debugPrint('[SongRepository] üîÑ Mapped "$collectionId" ‚Üí "$sanitized"');
    }

    return sanitized;
  }

  /// Sanitize song number for Firebase path usage
  String _sanitizeSongNumber(String songNumber) {
    return songNumber
        .replaceAll(' ', '_')
        .replaceAll('.', '_')
        .replaceAll('#', '_')
        .replaceAll('\$', '_')
        .replaceAll('[', '_')
        .replaceAll(']', '_')
        .replaceAll('/', '_')
        .replaceAll('\\', '_')
        .replaceAll(RegExp(r'[^\w\-]'), '_');
  }

  /// Check if collection ID needs sanitization
  bool _needsSanitization(String collectionId) {
    return collectionId != _sanitizeCollectionId(collectionId);
  }

  // ============================================================================
  // COLLECTION MIGRATION METHODS
  // ============================================================================

  /// Migrate collections with problematic names
  Future<List<CollectionMigrationResult>> migrateCollectionPaths() async {
    _logOperation('migrateCollectionPaths');

    if (!_isFirebaseInitialized) {
      throw Exception('Firebase not initialized - cannot migrate');
    }

    final database = _database;
    if (database == null) {
      throw Exception('Could not get database instance');
    }

    final results = <CollectionMigrationResult>[];

    try {
      debugPrint('[SongRepository] üîÑ Starting collection path migration...');

      // Get all collections
      final collectionsRef = database.ref(_collectionsPath);
      final collectionsSnapshot = await collectionsRef.get();

      if (!collectionsSnapshot.exists || collectionsSnapshot.value == null) {
        debugPrint('[SongRepository] No collections found for migration');
        return results;
      }

      final collectionsData =
          Map<String, dynamic>.from(collectionsSnapshot.value as Map);

      for (final entry in collectionsData.entries) {
        final originalId = entry.key;
        final safeId = _sanitizeCollectionId(originalId);

        if (originalId != safeId) {
          debugPrint(
              '[SongRepository] üîÑ Migrating collection "$originalId" ‚Üí "$safeId"');

          final migrationResult =
              await _migrateCollectionSongs(database, originalId, safeId);

          results.add(migrationResult);
        } else {
          debugPrint(
              '[SongRepository] ‚úÖ Collection "$originalId" already has safe path');
        }
      }

      debugPrint(
          '[SongRepository] üéâ Migration completed! Processed ${results.length} collections');
      return results;
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Migration failed: $e');
      results.add(CollectionMigrationResult(
        success: false,
        collectionId: 'unknown',
        originalPath: 'unknown',
        newPath: 'unknown',
        songsMigrated: 0,
        errorMessage: e.toString(),
      ));
      return results;
    }
  }

  /// Migrate songs from old collection path to new safe path
  Future<CollectionMigrationResult> _migrateCollectionSongs(
      FirebaseDatabase database, String originalId, String safeId) async {
    try {
      final originalPath = '$_collectionSongsPath/$originalId';
      final newPath = '$_collectionSongsPath/$safeId';

      debugPrint('[SongRepository] üìÅ Migrating: $originalPath ‚Üí $newPath');

      // Check if old path exists
      final oldRef = database.ref(originalPath);
      final oldSnapshot = await oldRef.get();

      if (!oldSnapshot.exists || oldSnapshot.value == null) {
        debugPrint(
            '[SongRepository] ‚ö†Ô∏è No songs found at old path: $originalPath');
        return CollectionMigrationResult(
          success: true,
          collectionId: originalId,
          originalPath: originalPath,
          newPath: newPath,
          songsMigrated: 0,
        );
      }

      // Get the songs data
      final songsData = oldSnapshot.value;
      final songCount = (songsData as Map?)?.length ?? 0;

      debugPrint('[SongRepository] üìä Found $songCount songs to migrate');

      // Copy to new path
      final newRef = database.ref(newPath);
      await newRef.set(songsData);

      debugPrint('[SongRepository] ‚úÖ Copied $songCount songs to new path');

      // Verify the copy worked
      final verifySnapshot = await newRef.get();
      if (!verifySnapshot.exists) {
        throw Exception('Failed to verify migration - new path is empty');
      }

      // Remove old path
      await oldRef.remove();
      debugPrint('[SongRepository] üóëÔ∏è Removed old path: $originalPath');

      return CollectionMigrationResult(
        success: true,
        collectionId: originalId,
        originalPath: originalPath,
        newPath: newPath,
        songsMigrated: songCount,
      );
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to migrate $originalId: $e');
      return CollectionMigrationResult(
        success: false,
        collectionId: originalId,
        originalPath: '$_collectionSongsPath/$originalId',
        newPath: '$_collectionSongsPath/$safeId',
        songsMigrated: 0,
        errorMessage: e.toString(),
      );
    }
  }

  /// Auto-migrate if needed (called before any collection operations)
  Future<void> _autoMigrateIfNeeded() async {
    try {
      // Check if we've already migrated in this session
      if (_collectionIdMapping.isNotEmpty) {
        return; // Already processed
      }

      debugPrint(
          '[SongRepository] üîç Checking if collection migration is needed...');

      final database = _database;
      if (database == null) return;

      // Quick check for problematic collection names
      final collectionsRef = database.ref(_collectionsPath);
      final collectionsSnapshot = await collectionsRef.get().timeout(
            const Duration(seconds: 5),
          );

      if (!collectionsSnapshot.exists || collectionsSnapshot.value == null) {
        return;
      }

      final collectionsData =
          Map<String, dynamic>.from(collectionsSnapshot.value as Map);
      bool needsMigration = false;

      for (final collectionId in collectionsData.keys) {
        if (_needsSanitization(collectionId)) {
          needsMigration = true;
          debugPrint(
              '[SongRepository] ‚ö†Ô∏è Found problematic collection name: "$collectionId"');
        }
      }

      if (needsMigration) {
        debugPrint('[SongRepository] üîÑ Auto-migration triggered...');
        final results = await migrateCollectionPaths();

        final successful = results.where((r) => r.success).length;
        final failed = results.where((r) => !r.success).length;

        debugPrint(
            '[SongRepository] üìä Migration complete: $successful successful, $failed failed');
      } else {
        debugPrint(
            '[SongRepository] ‚úÖ All collection paths are safe, no migration needed');
      }
    } catch (e) {
      debugPrint('[SongRepository] ‚ö†Ô∏è Auto-migration check failed: $e');
      // Don't throw - this is optional optimization
    }
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  /// Operation logging helper
  void _logOperation(String operation, [Map<String, dynamic>? details]) {
    if (kDebugMode) {
      _operationTimestamps[operation] = DateTime.now();
      _operationCounts[operation] = (_operationCounts[operation] ?? 0) + 1;

      final count = _operationCounts[operation];
      debugPrint('[SongRepository] üîß Operation: $operation (count: $count)');
      if (details != null) {
        debugPrint('[SongRepository] üìä Details: $details');
      }
    }
  }

  /// Connectivity attempt logging
  void _logConnectivityAttempt(String method, bool success, [String? details]) {
    if (kDebugMode) {
      final status = success ? '‚úÖ CONNECTED' : '‚ùå FAILED';
      debugPrint('[SongRepository] üåê $method: $status');
      if (details != null) {
        debugPrint('[SongRepository] üìÑ Details: $details');
      }
    }
  }

  /// Check real connectivity to Firebase with better error handling
  Future<bool> _checkRealConnectivity() async {
    try {
      debugPrint('[SongRepository] üîÑ Testing Firebase connectivity...');

      final connectedRef = FirebaseDatabase.instance.ref('.info/connected');
      final snapshot = await connectedRef.get().timeout(
            const Duration(seconds: 5),
            onTimeout: () => throw Exception('Connectivity check timeout'),
          );

      final isConnected = snapshot.value == true;
      _logConnectivityAttempt('Real-time check', isConnected);

      if (isConnected) {
        // Additional test: try to read a simple path to verify database access
        try {
          final testRef = FirebaseDatabase.instance.ref('test_connectivity');
          await testRef.get().timeout(const Duration(seconds: 3));
          debugPrint('[SongRepository] ‚úÖ Firebase database access confirmed');
          return true;
        } catch (testError) {
          debugPrint(
              '[SongRepository] ‚ö†Ô∏è Connected but database access failed: $testError');
          return false;
        }
      }

      return false;
    } catch (e) {
      _logConnectivityAttempt('Real-time check', false, e.toString());
      debugPrint('[SongRepository] ‚ùå Connectivity check failed: $e');
      return false;
    }
  }

  // ============================================================================
  // MAIN API METHODS (BACKWARD COMPATIBLE)
  // ============================================================================

  /// Get all songs - Enhanced with collection support but backward compatible
  Future<SongDataResult> getAllSongs() async {
    _logOperation('getAllSongs');

    if (!_isFirebaseInitialized) {
      debugPrint(
          '[SongRepository] Firebase not initialized, loading from assets');
      return await _loadAllFromLocalAssets();
    }

    final isOnline = await _checkRealConnectivity();
    if (!isOnline) {
      debugPrint('[SongRepository] No connectivity, loading from assets');
      return await _loadAllFromLocalAssets();
    }

    // Auto-migrate if needed
    await _autoMigrateIfNeeded();

    try {
      final database = _database;
      if (database == null) throw Exception('Could not get database instance');

      debugPrint('[SongRepository] üîÑ Fetching unified songs data...');

      // Fetch both legacy songs and collection songs in parallel
      final futures = await Future.wait([
        _fetchLegacySongs(database),
        _fetchCollectionSongs(database),
      ]);

      final legacySongs = futures[0] as Map<String, dynamic>?;
      final collectionSongs = futures[1] as Map<String, dynamic>?;

      // Parse unified data
      final inputData = {
        'legacySongs': legacySongs,
        'collectionSongs': collectionSongs,
      };

      final result =
          await compute(_parseUnifiedSongsData, json.encode(inputData));
      final songs = List<Song>.from(result['songs'] as List);

      debugPrint(
          '[SongRepository] ‚úÖ Loaded ${songs.length} total songs (ONLINE)');
      return SongDataResult(songs: songs, isOnline: true);
    } catch (e) {
      debugPrint(
          '[SongRepository] ‚ùå Unified fetch failed: $e. Falling back to assets');
      return await _loadAllFromLocalAssets();
    }
  }

  /// Get song by number - Enhanced with collection awareness
  Future<Song?> getSongByNumber(String songNumber) async {
    _logOperation('getSongByNumber', {'songNumber': songNumber});

    try {
      final songData = await getAllSongs();
      return songData.songs.firstWhere(
        (song) => song.number == songNumber,
        orElse: () => throw Exception('Song not found'),
      );
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to get song $songNumber: $e');
      return null;
    }
  }

  /// Get song by number with status
  Future<SongWithStatusResult> getSongByNumberWithStatus(
      String songNumber) async {
    _logOperation('getSongByNumberWithStatus', {'songNumber': songNumber});

    try {
      debugPrint('[SongRepository] üîç Getting song $songNumber with status...');
      final songData = await getAllSongs();

      final song = songData.songs.firstWhere(
        (song) => song.number == songNumber,
        orElse: () => throw Exception('Song not found'),
      );

      debugPrint(
          '[SongRepository] ‚úÖ Found song $songNumber (${songData.isOnline ? "ONLINE" : "OFFLINE"})');
      return SongWithStatusResult(song: song, isOnline: songData.isOnline);
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to get song $songNumber: $e');
      // If song not found, still return the online status
      final songData = await getAllSongs();
      return SongWithStatusResult(song: null, isOnline: songData.isOnline);
    }
  }

  /// Add song to legacy collection
  Future<void> addSong(Song song) async {
    _logOperation('addSong', {'songNumber': song.number});

    if (!_isFirebaseInitialized) {
      throw Exception('Firebase not initialized - cannot add song');
    }
    final database = _database;
    if (database == null) {
      throw Exception('Could not get database instance');
    }
    try {
      final songData = song.toJson();
      final DatabaseReference ref =
          database.ref('$_legacySongsPath/${song.number}');
      await ref.set(songData);
      debugPrint('[SongRepository] ‚úÖ Song added to legacy: ${song.number}');
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to add song: $e');
      rethrow;
    }
  }

  /// Update song
  Future<void> updateSong(String originalSongNumber, Song updatedSong) async {
    _logOperation('updateSong', {
      'originalNumber': originalSongNumber,
      'newNumber': updatedSong.number,
    });

    if (!_isFirebaseInitialized) {
      throw Exception('Firebase not initialized - cannot update song');
    }
    final database = _database;
    if (database == null) {
      throw Exception('Could not get database instance');
    }

    try {
      // If song number changed, delete old and add new
      if (originalSongNumber != updatedSong.number) {
        await deleteSong(originalSongNumber);
        await addSong(updatedSong);
      } else {
        final songData = updatedSong.toJson();
        final DatabaseReference ref =
            database.ref('$_legacySongsPath/${updatedSong.number}');
        await ref.update(songData);
      }
      debugPrint('[SongRepository] ‚úÖ Song updated: ${updatedSong.number}');
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to update song: $e');
      rethrow;
    }
  }

  /// Delete song
  Future<void> deleteSong(String songNumber) async {
    _logOperation('deleteSong', {'songNumber': songNumber});

    if (!_isFirebaseInitialized) {
      throw Exception('Firebase not initialized - cannot delete song');
    }
    final database = _database;
    if (database == null) {
      throw Exception('Could not get database instance');
    }

    try {
      final DatabaseReference ref =
          database.ref('$_legacySongsPath/$songNumber');
      await ref.remove();
      debugPrint('[SongRepository] ‚úÖ Song deleted: $songNumber');
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to delete song: $e');
      rethrow;
    }
  }

  // ============================================================================
  // ENHANCED METHODS (COLLECTION-AWARE)
  // ============================================================================

  /// Get all songs with enhanced collection data and user role support
  Future<UnifiedSongDataResult> getAllSongsEnhanced({String? userRole}) async {
    _logOperation('getAllSongsEnhanced', {'userRole': userRole});

    if (!_isFirebaseInitialized) {
      debugPrint(
          '[SongRepository] Firebase not initialized, loading from assets');
      return await _loadAllFromLocalAssetsEnhanced();
    }

    final isOnline = await _checkRealConnectivity();
    if (!isOnline) {
      debugPrint('[SongRepository] No connectivity, loading from assets');
      return await _loadAllFromLocalAssetsEnhanced();
    }

    // Auto-migrate if needed
    await _autoMigrateIfNeeded();

    try {
      final database = _database;
      if (database == null) throw Exception('Could not get database instance');

      debugPrint(
          '[SongRepository] üîÑ Fetching unified songs data with access control...');

      // Fetch both legacy songs and collection songs in parallel
      final futures = await Future.wait([
        _fetchLegacySongs(database),
        _fetchCollectionSongsWithAccess(database, userRole),
      ]);

      final legacySongs = futures[0] as Map<String, dynamic>?;
      final collectionSongs = futures[1] as Map<String, dynamic>?;

      // Parse unified data
      final inputData = {
        'legacySongs': legacySongs,
        'collectionSongs': collectionSongs,
      };

      final result =
          await compute(_parseUnifiedSongsData, json.encode(inputData));

      final songs = List<Song>.from(result['songs'] as List);
      final legacyCount = result['legacyCount'] as int;
      final collectionCount = result['collectionCount'] as int;
      final activeCollections =
          List<String>.from(result['activeCollections'] as List);

      debugPrint('[SongRepository] ‚úÖ Loaded ${songs.length} total songs');
      debugPrint(
          '[SongRepository] üìä Legacy: $legacyCount, Collections: $collectionCount');

      return UnifiedSongDataResult(
        songs: songs,
        isOnline: true,
        legacySongs: legacyCount,
        collectionSongs: collectionCount,
        activeCollections: activeCollections,
      );
    } catch (e) {
      debugPrint(
          '[SongRepository] ‚ùå Enhanced fetch failed: $e. Falling back to assets');
      return await _loadAllFromLocalAssetsEnhanced();
    }
  }

  /// Search songs across all sources with collection context
  Future<SongSearchResult> searchSongs(String searchTerm,
      {String? userRole}) async {
    _logOperation(
        'searchSongs', {'searchTerm': searchTerm, 'userRole': userRole});

    final allSongs = await getAllSongsEnhanced(userRole: userRole);
    final searchTermLower = searchTerm.toLowerCase();

    final matchingSongs = allSongs.songs.where((song) {
      return song.title.toLowerCase().contains(searchTermLower) ||
          song.number.contains(searchTerm) ||
          song.verses.any(
              (verse) => verse.lyrics.toLowerCase().contains(searchTermLower));
    }).toList();

    // Count matches by collection
    final Map<String, int> collectionMatches = {};
    for (final song in matchingSongs) {
      final collectionId = _getCollectionIdFromSong(song);
      if (collectionId != null) {
        collectionMatches[collectionId] =
            (collectionMatches[collectionId] ?? 0) + 1;
      }
    }

    return SongSearchResult(
      songs: matchingSongs,
      isOnline: allSongs.isOnline,
      searchTerm: searchTerm,
      totalMatches: matchingSongs.length,
      collectionMatches: collectionMatches,
    );
  }

  /// Get song by number with availability context and user role support
  Future<SongAvailabilityResult> getSongByNumberEnhanced(String songNumber,
      {String? userRole}) async {
    _logOperation('getSongByNumberAvailability',
        {'songNumber': songNumber, 'userRole': userRole});

    final allSongs = await getAllSongsEnhanced(userRole: userRole);

    final song = allSongs.songs.firstWhere(
      (s) => s.number == songNumber,
      orElse: () => Song(number: '', title: '', verses: []), // Empty marker
    );

    if (song.number.isEmpty) {
      // Song not found
      return SongAvailabilityResult(
        song: null,
        isOnline: allSongs.isOnline,
        foundInLegacy: false,
        foundInCollections: false,
        availableInCollections: [],
      );
    }

    // Determine where the song was found
    final collectionId = _getCollectionIdFromSong(song);
    final isFromCollection = collectionId != null;
    final availableCollections = isFromCollection ? [collectionId] : <String>[];

    return SongAvailabilityResult(
      song: song,
      isOnline: allSongs.isOnline,
      foundInLegacy: !isFromCollection,
      foundInCollections: isFromCollection,
      availableInCollections: availableCollections,
    );
  }

  // ============================================================================
  // PRIVATE HELPER METHODS
  // ============================================================================

  /// Fetch legacy songs from Firebase
  Future<Map<String, dynamic>?> _fetchLegacySongs(
      FirebaseDatabase database) async {
    try {
      final ref = database.ref(_legacySongsPath);
      final event = await ref.once().timeout(
            const Duration(seconds: 15),
            onTimeout: () => throw Exception('Legacy songs fetch timeout'),
          );

      if (event.snapshot.exists && event.snapshot.value != null) {
        return Map<String, dynamic>.from(event.snapshot.value as Map);
      }
      return null;
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to fetch legacy songs: $e');
      return null;
    }
  }

  /// Fetch collection songs without access control - UPDATED WITH PATH SAFETY
  Future<Map<String, dynamic>?> _fetchCollectionSongs(
      FirebaseDatabase database) async {
    try {
      debugPrint('[SongRepository] üîÑ Fetching all collection songs...');

      // Get all collections first to know which ones exist
      final collectionsRef = database.ref(_collectionsPath);
      final collectionsSnapshot = await collectionsRef.get().timeout(
            const Duration(seconds: 10),
            onTimeout: () => throw Exception('Collections fetch timeout'),
          );

      if (!collectionsSnapshot.exists || collectionsSnapshot.value == null) {
        debugPrint('[SongRepository] No collections found');
        return null;
      }

      final collectionsData =
          Map<String, dynamic>.from(collectionsSnapshot.value as Map);
      final collectionSongs = <String, dynamic>{};

      // Fetch songs from each collection
      for (final entry in collectionsData.entries) {
        try {
          final collectionId = entry.key;

          // ‚úÖ CRITICAL FIX: Sanitize collection ID for Firebase path
          final safeCollectionId = _sanitizeCollectionId(collectionId);
          debugPrint(
              '[SongRepository] Fetching from safe path: $_collectionSongsPath/$safeCollectionId');

          final songsRef =
              database.ref('$_collectionSongsPath/$safeCollectionId');
          final songsSnapshot = await songsRef.get().timeout(
                const Duration(seconds: 8),
                onTimeout: () => throw Exception('Collection songs timeout'),
              );

          if (songsSnapshot.exists && songsSnapshot.value != null) {
            collectionSongs[collectionId] =
                songsSnapshot.value; // Use original ID as key
            debugPrint(
                '[SongRepository] ‚úÖ Loaded songs from collection: $collectionId');
          }
        } catch (e) {
          debugPrint(
              '[SongRepository] ‚ùå Failed to fetch songs from collection ${entry.key}: $e');
          continue;
        }
      }

      return collectionSongs.isNotEmpty ? collectionSongs : null;
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Failed to fetch collection songs: $e');
      return null;
    }
  }

  /// Fetch collection songs with access control - UPDATED WITH PATH SAFETY
  Future<Map<String, dynamic>?> _fetchCollectionSongsWithAccess(
      FirebaseDatabase database, String? userRole) async {
    try {
      debugPrint(
          '[SongRepository] üîÑ Fetching collections with access control...');

      // First get accessible collections
      final collectionsRef = database.ref(_collectionsPath);
      final collectionsSnapshot = await collectionsRef.get().timeout(
            const Duration(seconds: 10),
            onTimeout: () => throw Exception('Collections fetch timeout'),
          );

      if (!collectionsSnapshot.exists || collectionsSnapshot.value == null) {
        debugPrint('[SongRepository] No collections found');
        return null;
      }

      final collectionsData =
          Map<String, dynamic>.from(collectionsSnapshot.value as Map);
      final collectionSongs = <String, dynamic>{};

      debugPrint(
          '[SongRepository] Found ${collectionsData.length} collections');

      // Filter collections by access and fetch their songs
      for (final entry in collectionsData.entries) {
        try {
          final collectionId = entry.key;
          final collectionData = Map<String, dynamic>.from(entry.value as Map);

          debugPrint('[SongRepository] Processing collection: $collectionId');

          // Check access level
          final accessLevel = collectionData['access_level'] ?? 'public';
          if (!_canUserAccessLevel(accessLevel, userRole)) {
            debugPrint(
                '[SongRepository] Access denied for collection $collectionId (level: $accessLevel)');
            continue;
          }

          // ‚úÖ CRITICAL FIX: Sanitize collection ID for Firebase path
          final safeCollectionId = _sanitizeCollectionId(collectionId);
          debugPrint(
              '[SongRepository] Using safe collection ID: $safeCollectionId for $collectionId');

          // Fetch songs from this collection using the safe ID
          final songsRef =
              database.ref('$_collectionSongsPath/$safeCollectionId');
          final songsSnapshot = await songsRef.get().timeout(
                const Duration(seconds: 8),
                onTimeout: () => throw Exception('Collection songs timeout'),
              );

          if (songsSnapshot.exists && songsSnapshot.value != null) {
            collectionSongs[collectionId] =
                songsSnapshot.value; // Use original ID as key
            debugPrint(
                '[SongRepository] ‚úÖ Loaded songs from collection: $collectionId');
          } else {
            debugPrint(
                '[SongRepository] No songs found in collection: $collectionId');
          }
        } catch (e) {
          debugPrint(
              '[SongRepository] ‚ùå Failed to fetch songs from collection ${entry.key}: $e');
          continue;
        }
      }

      debugPrint(
          '[SongRepository] Successfully fetched songs from ${collectionSongs.length} collections');
      return collectionSongs.isNotEmpty ? collectionSongs : null;
    } catch (e) {
      debugPrint(
          '[SongRepository] ‚ùå Failed to fetch collection songs with access: $e');
      return null;
    }
  }

  /// Check if user can access a specific access level
  bool _canUserAccessLevel(String accessLevel, String? userRole) {
    final role = userRole?.toLowerCase() ?? 'guest';
    const hierarchy = {
      'guest': 0,
      'user': 1,
      'registered': 1,
      'premium': 2,
      'admin': 3,
      'superadmin': 4,
    };

    const levelHierarchy = {
      'public': 0,
      'registered': 1,
      'premium': 2,
      'admin': 3,
      'superadmin': 4,
    };

    final userLevel = hierarchy[role] ?? 0;
    final requiredLevel = levelHierarchy[accessLevel.toLowerCase()] ?? 0;

    return userLevel >= requiredLevel;
  }

  /// Extract collection ID from song (helper method)
  String? _getCollectionIdFromSong(Song song) {
    // This would depend on how you store collection context in your Song model
    // For now, returning null for legacy songs
    // TODO: Implement based on your Song model structure when you add collection fields
    return null;
  }

  /// Load songs from local assets (backward compatible)
  Future<SongDataResult> _loadAllFromLocalAssets() async {
    try {
      debugPrint('[SongRepository] üìÅ Loading songs from local assets...');
      final localJsonString =
          await rootBundle.loadString('assets/data/lpmi.json');
      final songs = await compute(_parseSongsFromList, localJsonString);
      debugPrint(
          '[SongRepository] ‚úÖ Successfully loaded ${songs.length} songs from local assets (OFFLINE)');
      return SongDataResult(songs: songs, isOnline: false);
    } catch (assetError) {
      debugPrint('[SongRepository] ‚ùå Local asset loading failed: $assetError');
      return SongDataResult(songs: [], isOnline: false);
    }
  }

  /// Load songs from local assets (enhanced version)
  Future<UnifiedSongDataResult> _loadAllFromLocalAssetsEnhanced() async {
    try {
      debugPrint(
          '[SongRepository] üìÅ Loading songs from local assets (enhanced)...');
      final localJsonString =
          await rootBundle.loadString('assets/data/lpmi.json');
      final songs = await compute(_parseSongsFromAssets, localJsonString);

      debugPrint(
          '[SongRepository] ‚úÖ Loaded ${songs.length} songs from assets (OFFLINE)');
      return UnifiedSongDataResult(
        songs: songs,
        isOnline: false,
        legacySongs: songs.length,
        collectionSongs: 0,
        activeCollections: [],
      );
    } catch (assetError) {
      debugPrint('[SongRepository] ‚ùå Local asset loading failed: $assetError');
      return UnifiedSongDataResult(
        songs: [],
        isOnline: false,
        legacySongs: 0,
        collectionSongs: 0,
        activeCollections: [],
      );
    }
  }

  // ============================================================================
  // UTILITY & PERFORMANCE METHODS
  // ============================================================================

  /// Get repository performance metrics
  Map<String, dynamic> getPerformanceMetrics() {
    return {
      'operationCounts': Map.from(_operationCounts),
      'lastOperationTimestamps': _operationTimestamps.map(
        (key, value) => MapEntry(key, value.toIso8601String()),
      ),
      'firebaseInitialized': _isFirebaseInitialized,
      'databaseAvailable': _database != null,
      'legacySongsPath': _legacySongsPath,
      'collectionSongsPath': _collectionSongsPath,
      'collectionsPath': _collectionsPath,
      'collectionIdMappings': Map.from(_collectionIdMapping),
      'lastMetricsCheck': DateTime.now().toIso8601String(),
    };
  }

  /// Debug Firebase paths to identify issues
  Future<Map<String, dynamic>> debugFirebasePaths() async {
    final results = <String, dynamic>{};

    try {
      if (!_isFirebaseInitialized) {
        results['firebase_initialized'] = false;
        return results;
      }

      final database = _database;
      if (database == null) {
        results['database_available'] = false;
        return results;
      }

      results['firebase_initialized'] = true;
      results['database_available'] = true;

      // Test basic connectivity
      final connectivity = await _checkRealConnectivity();
      results['connectivity'] = connectivity;

      if (connectivity) {
        // Test collections path
        try {
          final collectionsRef = database.ref(_collectionsPath);
          final collectionsSnapshot =
              await collectionsRef.get().timeout(const Duration(seconds: 5));
          results['collections_readable'] = collectionsSnapshot.exists;
          results['collections_count'] = collectionsSnapshot.exists
              ? (collectionsSnapshot.value as Map?)?.length ?? 0
              : 0;

          if (collectionsSnapshot.exists && collectionsSnapshot.value != null) {
            final collectionsData =
                Map<String, dynamic>.from(collectionsSnapshot.value as Map);
            final collectionInfo = <String, dynamic>{};

            for (final entry in collectionsData.entries) {
              final collectionId = entry.key;
              final safeId = _sanitizeCollectionId(collectionId);

              collectionInfo[collectionId] = {
                'original_id': collectionId,
                'safe_id': safeId,
                'id_changed': collectionId != safeId,
                'needs_migration': _needsSanitization(collectionId),
              };

              // Test if we can read from this collection's songs
              try {
                final songsRef = database.ref('$_collectionSongsPath/$safeId');
                final songsSnapshot =
                    await songsRef.get().timeout(const Duration(seconds: 3));
                collectionInfo[collectionId]['songs_readable'] = true;
                collectionInfo[collectionId]['songs_count'] =
                    songsSnapshot.exists
                        ? (songsSnapshot.value as Map?)?.length ?? 0
                        : 0;
              } catch (e) {
                collectionInfo[collectionId]['songs_readable'] = false;
                collectionInfo[collectionId]['songs_error'] = e.toString();
              }
            }

            results['collection_details'] = collectionInfo;
          }
        } catch (e) {
          results['collections_error'] = e.toString();
        }

        // Test legacy songs path
        try {
          final legacyRef = database.ref(_legacySongsPath);
          final legacySnapshot =
              await legacyRef.get().timeout(const Duration(seconds: 5));
          results['legacy_songs_readable'] = legacySnapshot.exists;
          results['legacy_songs_count'] = legacySnapshot.exists
              ? (legacySnapshot.value as Map?)?.length ?? 0
              : 0;
        } catch (e) {
          results['legacy_songs_error'] = e.toString();
        }
      }

      results['debug_completed_at'] = DateTime.now().toIso8601String();
      return results;
    } catch (e) {
      results['debug_error'] = e.toString();
      results['debug_completed_at'] = DateTime.now().toIso8601String();
      return results;
    }
  }

  /// Get repository summary
  Map<String, dynamic> getRepositorySummary() {
    final currentUser = FirebaseAuth.instance.currentUser;
    return {
      'isFirebaseInitialized': _isFirebaseInitialized,
      'hasDatabaseInstance': _database != null,
      'userType': currentUser?.isAnonymous == true
          ? 'guest'
          : currentUser != null
              ? 'registered'
              : 'none',
      'userEmail': currentUser?.email,
      'lastCheck': DateTime.now().toIso8601String(),
      'collectionMappings': Map.from(_collectionIdMapping),
      'supportedFeatures': [
        'unifiedSongRetrieval',
        'collectionAwareness',
        'legacyCompatibility',
        'accessControl',
        'searchWithContext',
        'backwardCompatibility',
        'automaticMigration',
        'pathSafety',
      ],
    };
  }

  /// Test repository functionality
  Future<Map<String, dynamic>> testRepository() async {
    _logOperation('testRepository');

    final startTime = DateTime.now();
    final results = <String, dynamic>{};

    try {
      // Test Firebase connectivity
      results['firebaseInitialized'] = _isFirebaseInitialized;
      results['databaseAvailable'] = _database != null;

      if (_isFirebaseInitialized && _database != null) {
        // Test connectivity
        final isConnected = await _checkRealConnectivity();
        results['connectivity'] = isConnected;

        if (isConnected) {
          // Test reading songs
          try {
            final songsResult = await getAllSongs();
            results['songsReadable'] = true;
            results['songsCount'] = songsResult.songs.length;
            results['songsOnline'] = songsResult.isOnline;
          } catch (e) {
            results['songsReadable'] = false;
            results['songsError'] = e.toString();
          }

          // Test migration if needed
          try {
            await _autoMigrateIfNeeded();
            results['migrationTested'] = true;
            results['collectionMappings'] = Map.from(_collectionIdMapping);
          } catch (e) {
            results['migrationTested'] = false;
            results['migrationError'] = e.toString();
          }
        }
      }

      results['testDuration'] =
          DateTime.now().difference(startTime).inMilliseconds;
      results['testStatus'] = 'completed';
      results['testedAt'] = DateTime.now().toIso8601String();

      debugPrint('[SongRepository] ‚úÖ Repository test completed');
      return results;
    } catch (e) {
      results['testStatus'] = 'failed';
      results['error'] = e.toString();
      results['testDuration'] =
          DateTime.now().difference(startTime).inMilliseconds;
      results['testedAt'] = DateTime.now().toIso8601String();

      debugPrint('[SongRepository] ‚ùå Repository test failed: $e');
      return results;
    }
  }

  /// Manual migration trigger (for admin use)
  Future<Map<String, dynamic>> runMigration() async {
    _logOperation('runMigration');

    try {
      debugPrint('[SongRepository] üöÄ Manual migration triggered...');

      final results = await migrateCollectionPaths();

      final successful = results.where((r) => r.success).toList();
      final failed = results.where((r) => !r.success).toList();

      return {
        'success': true,
        'total_collections': results.length,
        'successful_migrations': successful.length,
        'failed_migrations': failed.length,
        'successful_results': successful
            .map((r) => {
                  'collection_id': r.collectionId,
                  'songs_migrated': r.songsMigrated,
                  'original_path': r.originalPath,
                  'new_path': r.newPath,
                })
            .toList(),
        'failed_results': failed
            .map((r) => {
                  'collection_id': r.collectionId,
                  'error': r.errorMessage,
                })
            .toList(),
        'completed_at': DateTime.now().toIso8601String(),
      };
    } catch (e) {
      debugPrint('[SongRepository] ‚ùå Manual migration failed: $e');
      return {
        'success': false,
        'error': e.toString(),
        'completed_at': DateTime.now().toIso8601String(),
      };
    }
  }
}
